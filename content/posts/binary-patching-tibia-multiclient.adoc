---
title: "Binary patching - creating Tibia MultiClient"
date: 2020-11-23
draft: false
tags: ["re", "patching", "binary", "reverse-engineering"]
:toc:
comments: true
---

== Childhood dreams
During some of my first school years I used to play an MMORPG game.
It had a reputation for having a lot of cheats for it. 
(Bad reputation still counts as reputation, right?)

People have created all kinds of software for it. 
Some small and harmless programs enabled you to change the outfit of your character client-side.
Others, much clever ones, made trees invisible, so you could see items hidden behind them.
The most advanced ones (called `bots`) could play the whole game for you.

Despite wide range of cheats, people had hard time choosing. 
You either had to pay a significant amount of money to buy cheats from a reliable party or 
download some sketchy `.exe` file and put your account at risk.
Both options stood far from ideal.

I remember I dreamed about having all the necessary skills to create such cheats all by myself.
A lot of time had passed since this dreaming, will I live up to my past self's expectations?

== MultiClient
Let's start with something simple.
Let's start with creating the `MultiClient`. 

Unmodified game client allows you to have only one instance of it running.
All subsequent clients will display an error message and then shut down.

image::https://i.ibb.co/4sMQBqK/ss.png[]

A `MultiClient` allows running multiple instances of the game client.

== Legal
I do consider creating cheats to online games as unethical, I really do.
Why I write about creating such a cheat then? 
In my defence, I will write about an old version of the game (`9.44`).
Current version (`11`) uses anti-cheat mechanism called `BattlEye`, and the described 
technique does not work in anymore.

== Naive attempt without debugger
At first, I thought about accomplishing my goal without running the application.
I wanted to use some decompiler, then patch it and then run it.

I searched for the string from the error message and found only one Cross Reference to it.

image::https://i.imgur.com/hW8qHA0.png[]

Following the Cross Reference I found a big `switch` statement, which probably handles all errors.

image::https://i.imgur.com/CaqZHdG.png[]

I zoomed in to see the error message I searched for.

image::https://i.imgur.com/vJTrry4.png[]

Let's backtrack from here and investigate how the `switch` value might end as `0x1c`.
Execution jumps to different cases based on `eax` value.
Value in `eax` basically equals to `arg3` value, decreased by 1.
To find out the value provided as `arg3` we need to find Cross References of `print_error_message` function.

image::https://i.imgur.com/74LmIJj.png[]

Caller of `print_error_message` provides its `arg2` as the third argument.

image::https://i.imgur.com/Ur1iVN9.png[]

image::https://i.imgur.com/xRULxFg.png[]

== Debugging strategy
== Patching 
== Mutex explanation




//Mutex links
//. https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createmutexa
//. https://docs.microsoft.com/en-us/windows/win32/sync/using-mutex-objects
//. https://stackoverflow.com/questions/3528877/can-someone-explain-mutex-and-how-it-is-used
//. https://nsis.sourceforge.io/mediawiki/index.php?title=Allow_only_one_installer_instance&oldid=22437
//. https://comp.os.ms-windows.programmer.win32.narkive.com/fxybQQtZ/regarding-createmutexa-and-createmutexw

